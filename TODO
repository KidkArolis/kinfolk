V1.0
- [x] atom
- [x] selector
- [ ] selector families
- [x] Provider
- [x] useSetter(atom)
- [x] useReducer(atom, reducer)
- [x] useSelector(select)
- [x] check the render order, see if possible to avoid nested re-re-renders
- [ ] useReducer test
- [x] rewrite useSetter using useReducer
- [ ] cleanup useSelector selectors when unmounting
- [ ] cleanup atom state when unmounting
- [ ] move selector family resolution and cache into provider tree, keep under get(fam, arg1, arg2, arg3)
- [ ] passing no deps to useSelector makes it hang
- [ ] test mounting same atom many times
- [ ] throw if selector or useSelector is passed an atomRef directly
- [ ] do not unmount/clear standalone selectors()
- [ ] provide a way to reset standalone selectors()
- [ ] make it work with multiple nested Providers in the tree (library use case)
- [ ] completely isolated atoms (createContext?)
- [ ] scoped providers or creatable providers
- [ ] can we make selector recomputes lazy, mark as dirty, only read if needed?
- [ ] ability to reset / clear the atom (can we just use useSetter?)
- [ ] TypeScript
- [ ] Document: caveat with library use case, multiple versions/instances of this lib might not work like React
- [ ] Document: caveat tracking atom dependencies inside getSnapshot() of useSyncExternalStore, in principle no different than what Recoil is doing, but the behaviour might be a bit undefined
- [ ] Look into how Recoil binds to state and stores it
- [ ] getState() improve by separating inline selectors and keeping global atoms more browseable
- [ ] turn label and equals into an option
- [ ] consider allowing equals only at the provider level (? library use case ? or make a custom useSelector/selector with equals)

Goals
-----
- [x] One global store
- [x] But referenced modularly via atoms
- [x] Can combine multiple atoms
- [x] Incorporate reselect style memoisation
- [x] Good for single value contexts
- [x] Good for large caches ala figbird
- [x] React 18 compatible
- [x] As tiny as possible
- [x] As few hooks as possible
